{\rtf1\ansi\ansicpg1252\cocoartf1404\cocoasubrtf460
{\fonttbl\f0\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;}
\paperw11900\paperh16840\margl1440\margr1440\vieww10800\viewh8400\viewkind0
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\f0\fs24 \cf0 our project:\
consists of 3 tasks\
the third task is independent, therefore it is developed in parallel with the other two.\
regarding this task we are already able to make the videos we\'92ve shown in this presentation.\
\
regarding the first two task, we\'92re focusing on the first:\
UML\
read data from .xml\
practice with itertool py module combinatorics\
2 strategies to solve it\
	- leading nodes\
	- members\
find all possibilities\
discard those that do not make sense\
brute force will work for any given structure\
\
##############################\
5-6\
in a front crash \
a car crashes into a wall\
distinguish two parts: front rear\
	what separates them is the firewall\
	\
a crash design is satisfactory\
if during the crash the deformation of the front part is sufficient to stop the car, without:\
											- deformation of the firewall\
											- excessive acceleration\
7\
model the front part as puzzle of rods\
\
8\
leaving the rendering, this is how our problem looks like\
\
the structure is made of members like this\
\
9\
each of them has\'85\
it represents a real part of the front car\
\
when we model the front part some comps may be negligible from the perspective of crashworthiness\
analysis some are taken into account\
\
10\
components in serial connection make a load path\
\
11\
a load path might be more complicated, masses and gaps\
\
12\
ta-daaaaaan\
take all together and this is the structure that we might have to solve}